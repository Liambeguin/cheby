= Cheby User Guide
CERN
v0.9, 2018-09-12

== What is Cheby ?

*Cheby* is both a text description of the interface between hardware
and software, and a tool to automatically generate code or
documentation from the text files.

In Cheby, the hardware appears to the software as a block of address in the
physical memory space.  There might be other way to interface hardware and
software (for example through a standard serial bus like USB or through a
network).

The block of address is named the memory map of the hardware.  The memory map
is a map between addresses and hardware elements like registers or memories.

The hardware elements supported by Cheby are:

* Registers.  A register uses one word of memory (usually 32 bits) or
two (so 64 bits), and is divided into fields (a group of bit).  Some
bits of the registers can be unused.  The difference between a
register and a memory is that hardware has direct access to a
register, there are wires between the register and the hardware so as
soon as the software writes to a register the hardware 'can' see the
new value. A register is usually read-write: the value of the register
is defined by the last write (from the software) and the software
always reads the last value.  A register can also be read-only: the
hardware defines the value that is read.  It is also possible that a
read triggers some changes in the hardware.  Finally a register can be
write-only, and usually a write triggers an action.  In that case, a
value read has no meaning.

* Memories. A memory is like a RAM memory except that hardware also
has access to it (through a second port, hence the name dual
port).  Memories are used when a certain amount of data has to be
transfered or to configure hardware for data transfers (like DMA
descriptors).  To avoid possible conflicts, memories are usually one
direction: the software can read and the hardware can write, or the
software can write and the hardwire can read.

* Submap.  A submap is a sub-block of the memory map (an aligned
continuous range of address) either defined by an external file or
will be available to the hardware designer.  Submaps make possible to
create a hierarchy of blocks and to create custom blocks.

A fundamental feature of the Cheby text description is non-ambiguity: the
memory map is defined by the file and there is only one way to assign addresses
to hardware elements.

Once the text file is written it is possible to invoke the cheby tool to
generate:

* C headers
* Device drivers
* HDL code
* HTML documentation

The automatic generation of these files avoid a tedious work and ensure
coherency between them.


== User Starting Guide

Let's work on a very simple design: a counter.  The hardware
increments a countewr every cycle until it reaches a maximal value,
then it starts again from 0.

As a designer, you have to implement the counter but you can use Cheby
to generate the interface.  The counter needs:

* A one bit register to enable/disable it.

* A 32-bit register containing the maximal value

* A 32-bit register with the current value.

In this user starting guide only the `cheby` command line tool is used, and
the input file is created by any text editor.

Let's assume the design uses the wishbone bus, and create a Cheby file that
describes the above elements.

[source]
----
include::srcs/counter.cheby[]
----

The description of the file format is documented later in this guide.

For the hardware designer, cheby can generate the hardware interface:
for VHDL this is an entity and its associated architecture and for
verilog this is a module.  The hardware interface contains the wishbone bus,
the registers described in the file, the decoding logic, and ports for the
registers.

To generate VHDL:
[source]
----
  cheby --gen-hdl=counter.vhdl -i counter.cheby
----

Here is the entity part generated by the tool:
[source]
----
include::srcs/counter_entity.vhdl[]
----

You can see the wishbone ports and the ports for the counter.

As an hardware designer, you have to write the HDL code for the counter logic.
The enable and maximum value are given by the interface, and you should give
the current value.

Because the interface is defined (and hopefully well documented), it is also
possible for the software developer to start the software part.  The SW
developer needs to program the register and therefore to know the register
map.  So let's generate the corresponding C header:
[source]
----
include::srcs/counter.h[]
----

The absolute address of the counter is determined by the instantiation
of this module, but you can refer directly to the registers.

== Cheby File Format

=== General Structure

The Cheby file format is based on YAML, so that there is no new format to
invent and many text editors have already support for it.  However the file
extension is usually `.cheby`.

The file describes a tree, each node has attributes and some of the nodes also
have children (a list of nodes).  The nodes are memory map, register, field,
array, block and submap.

Some attributes are common to all nodes:

* `name`: The name of the node.  This is required for all nodes.  The name is
also used to create HDL or C names in general files.

* `description`: This should be a short text that explain the purpose
of the node.  The description is copied into the code (as a comment)
to make it more readable.  This attribute is not required but it is recommended
to always provide it.

* `comment`: This is a longer text that will be copied into the generated
documentation.

* `children`: For nodes that have children, this is a list of the children.

* `address`: An optional address relative to the parent.  The address must
be correctly aligned.  If not provided or it the value is `next`, then the
address is computed using the previous one and the alignment.  It is possible
to go backward by providing explicit address (eg: the first child has address 4
and the second one has address 0), but this is not recommended and be a source
of errors (in particular with automatic addresses that are always computed
from the previous node). Overlapping addresses are detected by the tools.

* `x-NAME`: Extensions for tool or feature `NAME`. The Cheby file
format is extensible so that new tools can be easily created without
backward compatibility issues.

* `x-hdl`: Extensions for hdl generation.

=== Header

A cheby file is an associative array named `memory-map`.  The only purpose of
this name is to easily refuse a random YAML file.

The `bus` attribute specifies which bus will be used to interface the CPU with
the HW module.  It can be:

* wb-32-be: non-pipelined wishbone with 32 bit of data using the big-endian
convention

* axi4-lite-32: AIX4 lite bus with 32 bit of data

* cern-be-vme-SZ: CERN VME-like bus using `SZ` data bit.  `SZ` can be
8, 16 or 32.

If you need to reserve area in a module, you can use the `size` attribute to
specify the size (in bytes) of the memory space used by the module.

=== Registers

==== Plain Registers

==== Fields

=== RAMs

=== Repetition

=== submap

If the `filename` attribue is not present, then this is a generic
submap and a bus port is generated in the HDL.  The size of the submap
is required.

If the `filename` attribute is present, the `size` attribute is not allowed as
the size of the submap is defined by the memory map given by the file.  If the
`interface` attribute is present and set to `include`, then the memory map
described by the file is included directly, otherwise a bus interface is
generated in the HDL.


==  Generated HDL

===  AXI4-Lite

There are several restrictions from the AMBA AXI standard:

* There can be no combinatorial paths between input and
output signals (A3.2.1).  So there must be at least one
register.

* A source is not permitted to wait until READY is asserted before
asserting VALID.  Likewise, a destination is permitted to wait for
VALID to be assert before asserting the corresponding READY (A3.2.1).

There are registers for each channel.  The W and AW channels waits until
both have a request, handle the request and then become ready when the B
channel becomes ready.

== wbgen Compatibility

== Gena Compatibility

== Cheby Tools

=== Generating VHDL

=== Generating Verilog

=== Generating EDGE file

=== Generating C header

=== Generating HTML documentation
